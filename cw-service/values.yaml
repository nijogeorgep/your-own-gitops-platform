# Default values for cw-service.
# This is a YAML-formatted file.
# Declare variables to be passed into your templates.

# This will set the replicaset count more information can be found here: https://kubernetes.io/docs/concepts/workloads/controllers/replicaset/
replicaCount: 1

# This sets the container image more information can be found here: https://kubernetes.io/docs/concepts/containers/images/
image:
  repository: nginx
  # This sets the pull policy for images.
  pullPolicy: IfNotPresent
  # Overrides the image tag whose default is the chart appVersion.
  tag: ""

# This is for the secrets for pulling an image from a private repository more information can be found here: https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry/
imagePullSecrets: []
# This is to override the chart name.
nameOverride: ""
fullnameOverride: ""

# Naming convention: <app-name>-<environment>-<flavor>-<region>
# These values are used to construct resource names following the standard naming pattern
# Note: 'flavor' is optional - if omitted, format becomes: <app-name>-<environment>-<region>
environment: ""  # e.g., dev, staging, prod
flavor: ""       # e.g., api, worker, cache (OPTIONAL - use for service variants)
region: ""       # e.g., us-east-1, eu-west-1, apse-1

# Namespace configuration
# Allows creating and customizing the namespace where resources are deployed
namespace:
  # Whether to create the namespace (if false, namespace must exist)
  create: false
  # Custom namespace name (if not set, uses Release.Namespace)
  name: ""
  # Additional labels for the namespace
  labels: {}
    # environment: production
    # team: platform
    # cost-center: engineering
  # Annotations for the namespace
  annotations: {}
    # owner: platform-team@example.com
    # description: "Production workloads"
  
  # ResourceQuota - limit total resource consumption in namespace
  # https://kubernetes.io/docs/concepts/policy/resource-quotas/
  resourceQuota:
    enabled: false
    hard: {}
      # requests.cpu: "10"
      # requests.memory: 20Gi
      # limits.cpu: "20"
      # limits.memory: 40Gi
      # pods: "50"
      # services: "10"
      # persistentvolumeclaims: "5"
    scopeSelector: {}
  
  # LimitRange - default resource limits for containers
  # https://kubernetes.io/docs/concepts/policy/limit-range/
  limitRange:
    enabled: false
    limits: []
      # - type: Container
      #   default:
      #     cpu: 500m
      #     memory: 512Mi
      #   defaultRequest:
      #     cpu: 100m
      #     memory: 128Mi
      #   max:
      #     cpu: 2000m
      #     memory: 2Gi
      #   min:
      #     cpu: 50m
      #     memory: 64Mi
      # - type: Pod
      #   max:
      #     cpu: 4000m
      #     memory: 4Gi

# This section builds out the service account more information can be found here: https://kubernetes.io/docs/concepts/security/service-accounts/
# ServiceAccount is always created as a default requirement for security best practices
serviceAccount:
  # Automatically mount a ServiceAccount's API credentials?
  automount: true
  # Annotations to add to the service account.
  annotations: {}
  # The name of the service account to use.
  # If not set, a name is generated using the fullname template.
  name: ""

# This is for setting Kubernetes Annotations to a Pod.
# For more information checkout: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/
podAnnotations: {}
# This is for setting Kubernetes Labels to a Pod.
# For more information checkout: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
podLabels: {}

podSecurityContext: {}
  # fsGroup: 2000

securityContext: {}
  # capabilities:
  #   drop:
  #   - ALL
  # readOnlyRootFilesystem: true
  # runAsNonRoot: true
  # runAsUser: 1000

# Environment variables for the container
# https://kubernetes.io/docs/tasks/inject-data-application/define-environment-variable-container/
# Tip: To inject deployment context (service name, environment, region), reference the values:
# In your environment-specific values file (e.g., cw-common/values-prod.yaml):
#   env:
#     - name: SERVICE_NAME
#       value: "myapp"  # Or use {{ .Values.nameOverride }}
#     - name: ENVIRONMENT
#       value: "prod"   # Or use {{ .Values.environment }}
#     - name: REGION
#       value: "us-east-1"  # Or use {{ .Values.region }}
#     - name: FLAVOR
#       value: "api"    # Or use {{ .Values.flavor }}
env: []
  # - name: LOG_LEVEL
  #   value: "info"
  # - name: SECRET_KEY
  #   valueFrom:
  #     secretKeyRef:
  #       name: app-secrets
  #       key: secret-key

# Environment variables from ConfigMaps or Secrets
# https://kubernetes.io/docs/tasks/configure-pod-container/configure-pod-configmap/#configure-all-key-value-pairs-in-a-configmap-as-container-environment-variables
envFrom: []
  # - configMapRef:
  #     name: app-config
  # - secretRef:
  #     name: app-secrets

# This is for setting up a service more information can be found here: https://kubernetes.io/docs/concepts/services-networking/service/
service:
  # This sets the service type more information can be found here: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types
  type: ClusterIP
  # This sets the ports more information can be found here: https://kubernetes.io/docs/concepts/services-networking/service/#field-spec-ports
  # Single port configuration (backward compatible)
  port: 80
  # Multiple ports configuration with protocol support
  # When using multiple ports, this overrides the single 'port' setting
  ports: []
    # - name: http
    #   port: 80
    #   targetPort: 8080
    #   protocol: TCP
    # - name: https
    #   port: 443
    #   targetPort: 8443
    #   protocol: TCP
    # - name: grpc
    #   port: 9090
    #   targetPort: 9090
    #   protocol: TCP

# This block is for setting up the ingress for more information can be found here: https://kubernetes.io/docs/concepts/services-networking/ingress/
ingress:
  enabled: false
  className: ""
  annotations: {}
    # kubernetes.io/ingress.class: nginx
    # kubernetes.io/tls-acme: "true"
  hosts:
    - host: chart-example.local
      paths:
        - path: /
          pathType: ImplementationSpecific
  tls: []
    # - secretName: chart-example-tls
    #   hosts:
    #     - chart-example.local

# -- Expose the service via gateway-api HTTPRoute
# Requires Gateway API resources and suitable controller installed within the cluster
# (see: https://gateway-api.sigs.k8s.io/guides/)
httpRoute:
  # HTTPRoute enabled.
  enabled: false
  # HTTPRoute annotations.
  annotations: {}
  # Which Gateways this Route is attached to.
  parentRefs:
  - name: gateway
    sectionName: http
    # namespace: default
  # Hostnames matching HTTP header.
  hostnames:
  - chart-example.local
  # List of rules and filters applied.
  rules:
  - matches:
    - path:
        type: PathPrefix
        value: /headers
  #   filters:
  #   - type: RequestHeaderModifier
  #     requestHeaderModifier:
  #       set:
  #       - name: My-Overwrite-Header
  #         value: this-is-the-only-value
  #       remove:
  #       - User-Agent
  # - matches:
  #   - path:
  #       type: PathPrefix
  #       value: /echo
  #     headers:
  #     - name: version
  #       value: v2

resources: {}
  # We usually recommend not to specify default resources and to leave this as a conscious
  # choice for the user. This also increases chances charts run on environments with little
  # resources, such as Minikube. If you do want to specify resources, uncomment the following
  # lines, adjust them as necessary, and remove the curly braces after 'resources:'.
  # limits:
  #   cpu: 100m
  #   memory: 128Mi
  # requests:
  #   cpu: 100m
  #   memory: 128Mi

# This is to setup the liveness and readiness probes more information can be found here: https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/
# Default configuration is optimized for Spring Boot Actuator endpoints
livenessProbe:
  httpGet:
    path: /actuator/health/liveness
    port: http
  initialDelaySeconds: 30
  periodSeconds: 10
  timeoutSeconds: 5
  failureThreshold: 3
  # For gRPC services, use:
  # grpc:
  #   port: 9090
readinessProbe:
  httpGet:
    path: /actuator/health/readiness
    port: http
  initialDelaySeconds: 20
  periodSeconds: 5
  timeoutSeconds: 3
  failureThreshold: 3
  # For gRPC services, use:
  # grpc:
  #   port: 9090

# This section is for setting up autoscaling more information can be found here: https://kubernetes.io/docs/concepts/workloads/autoscaling/
autoscaling:
  enabled: false
  minReplicas: 1
  maxReplicas: 100
  targetCPUUtilizationPercentage: 80
  # targetMemoryUtilizationPercentage: 80
  
  # Scaling behavior controls how fast the HPA scales up/down
  # If not specified, uses sensible defaults (see hpa.yaml template)
  # behavior:
  #   scaleDown:
  #     stabilizationWindowSeconds: 300  # Wait 5 minutes before scaling down
  #     policies:
  #     - type: Percent
  #       value: 50  # Scale down by max 50% of current replicas
  #       periodSeconds: 60
  #     - type: Pods
  #       value: 2  # Scale down by max 2 pods
  #       periodSeconds: 60
  #     selectPolicy: Min  # Use the policy that scales down the least
  #   scaleUp:
  #     stabilizationWindowSeconds: 0  # Scale up immediately
  #     policies:
  #     - type: Percent
  #       value: 100  # Scale up by max 100% of current replicas
  #       periodSeconds: 60
  #     - type: Pods
  #       value: 4  # Scale up by max 4 pods
  #       periodSeconds: 60
  #     selectPolicy: Max  # Use the policy that scales up the most

# Additional volumes on the output Deployment definition.
volumes: []
  # - name: foo
  #   secret:
  #     secretName: mysecret
  #     optional: false

# Additional volumeMounts on the output Deployment definition.
volumeMounts: []
  # - name: foo
  #   mountPath: "/etc/foo"
  #   readOnly: true

nodeSelector: {}

tolerations: []

affinity: {}

# Istio service mesh resources (managed by cw-istio subchart)
# Pass service name and port to the subchart automatically
cw-istio:
  enabled: false
  service:
    # These values are automatically populated from the parent chart
    name: ""  # Will be set to the full service name
    port: 80  # Will be set to service.port
  
  # VirtualService configuration
  virtualService:
    enabled: false
    annotations: {}
    hosts:
      - "*"
    gateways:
      - istio-system/gateway
    http:
      - match:
        - uri:
            prefix: /
        route:
          - destination:
              port: 80
            weight: 100
    # Example: Canary routing
    # http:
    #   - match:
    #     - uri:
    #         prefix: /
    #     route:
    #       - destination:
    #           subset: stable
    #         weight: 90
    #       - destination:
    #           subset: canary
    #         weight: 10
  
  # DestinationRule configuration
  destinationRule:
    enabled: false
    annotations: {}
    trafficPolicy:
      loadBalancer:
        simple: LEAST_CONN
      connectionPool:
        tcp:
          maxConnections: 100
        http:
          http1MaxPendingRequests: 50
          http2MaxRequests: 100
      outlierDetection:
        consecutiveErrors: 5
        interval: 30s
        baseEjectionTime: 30s
        maxEjectionPercent: 50
    # Subsets for canary deployments
    subsets: []
    # - name: stable
    #   labels:
    #     version: stable
    # - name: canary
    #   labels:
    #     version: canary
  
  # Gateway configuration
  gateway:
    enabled: false
    annotations: {}
    selector:
      istio: ingressgateway
    servers:
      - port:
          number: 80
          name: http
          protocol: HTTP
        hosts:
          - "*"
    # HTTPS example:
    # servers:
    #   - port:
    #       number: 443
    #       name: https
    #       protocol: HTTPS
    #     hosts:
    #       - "*.example.com"
    #     tls:
    #       mode: SIMPLE
    #       credentialName: example-credential
  
  # PeerAuthentication configuration
  peerAuthentication:
    enabled: false
    annotations: {}
    mtlsMode: STRICT  # STRICT, PERMISSIVE, or DISABLE
    portLevelMtls: {}
    # Example:
    # portLevelMtls:
    #   "8080":
    #     mode: DISABLE

# Argo Rollouts configuration for progressive delivery
# Enable this for canary deployments or blue-green releases
# IMPORTANT: Mutually exclusive with standard Deployment
# When enabled, Deployment template is disabled automatically
rollout:
  # Enable Argo Rollout (replaces standard Deployment)
  enabled: false
  
  # Strategy: "canary" or "bluegreen"
  strategy: canary
  
  # Number of old ReplicaSets to retain for rollback
  revisionHistoryLimit: 3
  
  # Canary deployment configuration
  canary:
    # Traffic shift steps (progressive rollout)
    # Customize per environment (faster for dev, slower for prod)
    steps: []
    # Example progressive rollout:
    # steps:
    #   - setWeight: 10
    #   - pause: {duration: 5m}
    #   - setWeight: 25
    #   - pause: {duration: 5m}
    #   - setWeight: 50
    #   - pause: {duration: 10m}
    #   - setWeight: 75
    #   - pause: {duration: 5m}
    
    # Default pause duration between steps (if not specified in steps)
    pauseDuration: "5m"
    
    # Maximum surge during rollout (extra pods beyond desired count)
    maxSurge: 1
    
    # Maximum unavailable during rollout
    maxUnavailable: 0
    
    # Analysis for automated promotion/rollback
    # Integrate with Prometheus, Datadog, New Relic, etc.
    analysis: {}
    # Example with Prometheus:
    # analysis:
    #   templates:
    #   - templateName: success-rate
    #   args:
    #   - name: service-name
    #     value: myapp
  
  # Blue-Green deployment configuration
  blueGreen:
    # Automatically promote new version without manual approval
    autoPromotionEnabled: false
    
    # Time to wait before scaling down old version (allows rollback)
    scaleDownDelaySeconds: 30
    
    # Analysis before switching traffic to new version
    prePromotionAnalysis: {}
    
    # Analysis after traffic switched (can trigger rollback)
    postPromotionAnalysis: {}

